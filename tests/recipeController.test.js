// Import necessary modules and functions
const {
    getRecipes,
    getAllRecipesByUser,
    getFilteredRecipesByUser,
    getAllRecipes,
    getRecipeIngredients,
    insertRecipeByUser,
    insertRecipeIngredientsByRecipeId,
    updateRecipeByUser,
    updateRecipeByRecipeId,
    patchRecipeByUser,
    patchRecipeByRecipeId,
    deleteRecipeByUser,
    deleteRecipeByRecipeId,
    deleteRecipeIngredientByRecipeId,
    isUserRecipe
} = require('../controllers/recipeController');
const {
    getRecipeById,
    getRecipesByUserId,
    getAllStoredRecipes,
    getRecipeIngredientsById,
    insertRecipe,
    insertRecipeIngredient,
    updateRecipeDetailsbyUser,
    editRecipe,
    deleteRecipe,
    deleteRecipeIngredients
} = require('../models/recipe');
const pantry = require('../models/pantry');
const recipeService = require('../services/recipeService');
const recipeController = require('../controllers/recipeController');
const recipe = require('../models/recipe');
const db = require('../middleware/db');
const axios = require('axios');
const sql = require('mssql');
const { tr, is } = require('date-fns/locale');

// Mock the required modules
jest.mock('../models/pantry');
jest.mock('../services/recipeService');
jest.mock('../models/recipe');
// Mock the required functions
jest.mock('../controllers/recipeController', () => ({
    ...jest.requireActual('../controllers/recipeController')
}));
jest.mock('../middleware/db', () => {
    const mockPool = {
        connect: jest.fn(),
        request: jest.fn(),
        close: jest.fn(),
        // Add other methods as needed
    };

    const poolPromise = new Promise((resolve, reject) => {
        // Resolve with the mock pool
        resolve(mockPool);
    });

    return {
        sql: jest.requireActual('mssql'), // Use actual mssql library for `sql` part
        poolPromise, // Export the mocked poolPromise
    };
});

/* Note that recipeid in SQL will be UUID, userid will be generated by MongoDB, 
 while spoonacularId for a recipe will be 6 numerical digits in a string format.
 for testing purposes, testing data is simplified */

describe('Recipe Controller Tests', () => {
    let pool;
    // Mock poolPromise behavior
    beforeAll(async () => {
        try {
            // Initialize the database connection pool or other resources
            pool = await db.poolPromise;
        } catch (error) {
            console.error('Error initializing pool:', error);
            throw error;
        }
    });
    // Clean up resources after all tests
    afterAll(async () => {
        try {
            // Close database connections or other cleanup tasks
            if (pool) {
                await pool.close();
            }
        } catch (error) {
            console.error('Error closing pool:', error);
            throw error;
        }
    });
    afterEach(() => {
        jest.clearAllMocks();
    });

    // Test cases for getRecipes function
    describe('getRecipes', () => {
        it('should fetch recipes and store them in the database', async () => {
            // Mock data and setup for the test
            const mockUserId = 'user123';
            const mockIngredients = [{ name: 'ingredient1' }, { name: 'ingredient2' }];
            const mockRecipes = [{ id: 'recipe1', title: 'Recipe 1' }, { id: 'recipe2', title: 'Recipe 2' }];

            pantry.getIngredients.mockResolvedValue(mockIngredients);
            recipeService.fetchRecipes.mockResolvedValue(mockRecipes);
            insertRecipe.mockResolvedValue(); // Mock insertRecipe function

            const req = { userid: mockUserId };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getRecipes(req, res);

            // Assertions
            expect(pantry.getIngredients).toHaveBeenCalledWith(mockUserId);
            expect(recipeService.fetchRecipes).toHaveBeenCalledWith(mockIngredients);
            expect(insertRecipe).toHaveBeenCalledTimes(mockRecipes.length);
            expect(res.status).toHaveBeenCalledWith(201);
            expect(res.json).toHaveBeenCalledWith(mockRecipes);
        });

        it('should handle errors during recipe fetching and storing', async () => {
            // Mock data and setup for the test
            pantry.getIngredients.mockRejectedValue(new Error('Mock error'));

            const req = { userid: 'user123' };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getRecipes(req, res);

            // Assertions
            expect(pantry.getIngredients).toHaveBeenCalledWith(req.userid);
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error fetching and storing recipes', error: 'Mock error' });
        });
    });

    // Test cases for getAllRecipesByUser function
    describe('getAllRecipesByUser', () => {
        it('should fetch all recipes for a user', async () => {
            // Mock data and setup for the test
            const mockUserId = 'user123';
            const mockRecipes = [{ id: 'recipe1', title: 'Recipe 1' }, { id: 'recipe2', title: 'Recipe 2' }];

            getRecipesByUserId.mockResolvedValue(mockRecipes);

            const req = { userid: mockUserId };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getAllRecipesByUser(req, res);

            // Assertions
            expect(getRecipesByUserId).toHaveBeenCalledWith(mockUserId);
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith(mockRecipes);
        });

        it('should handle error when fetching recipes by user ID', async () => {
            // Mock data and setup for the test
            getRecipesByUserId.mockRejectedValue(new Error('Mock error'));

            const req = { userid: 'user123' };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getAllRecipesByUser(req, res);

            // Assertions
            expect(getRecipesByUserId).toHaveBeenCalledWith(req.userid);
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error getting recipes by user ID', error: 'Mock error' });
        });

        it('should handle case where no recipes are found for a user', async () => {
            // Mock data and setup for the test
            getRecipesByUserId.mockResolvedValue([]);

            const req = { userid: 'user123' };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getAllRecipesByUser(req, res);

            // Assertions
            expect(getRecipesByUserId).toHaveBeenCalledWith(req.userid);
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'No recipes found for the user' });
        });

        it('should handle case where user ID is not provided', async () => {
            const req = {}; // Simulating missing userid
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getAllRecipesByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'User ID not provided' });
        });
    });

    // Test cases for getFilteredRecipesByUser
    describe('getFilteredRecipesByUser', () => {
        afterEach(() => {
            jest.clearAllMocks();
        });

        it('should fetch filtered recipes based on user preferences', async () => {
            // Mock request and response objects
            const req = {
                userid: 'user123',
                body: [{ name: 'ingredient1' }, { name: 'ingredient2' }],
                excludedIngredients: ['dairy'],
                intolerances: ['gluten'],
                dietaryRestrictions: ['vegetarian'],
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            const mockFilteredRecipes = [{ id: 'recipe1', title: 'Recipe 1' }, { id: 'recipe2', title: 'Recipe 2' }];

            // Mocking recipeService.fetchFilteredRecipes to resolve with mockFilteredRecipes
            recipeService.fetchFilteredRecipes.mockResolvedValue(mockFilteredRecipes);

            // Call the controller function
            await getFilteredRecipesByUser(req, res);

            // Assertions
            expect(recipeService.fetchFilteredRecipes).toHaveBeenCalledWith(
                req.body,
                req.excludedIngredients,
                req.intolerances,
                req.dietaryRestrictions
            );
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith(mockFilteredRecipes);
        });

        it('should handle missing user ID', async () => {
            // Mock request and response objects
            const req = {};
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getFilteredRecipesByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'User ID not provided' });
            // Ensure that fetchFilteredRecipes was not called
            expect(recipeService.fetchFilteredRecipes).not.toHaveBeenCalled();
        });

        it('should handle missing ingredients', async () => {
            // Mock request and response objects
            const req = { userid: 'user123' };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getFilteredRecipesByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Ingredients must be provided' });
            // Ensure that fetchFilteredRecipes was not called
            expect(recipeService.fetchFilteredRecipes).not.toHaveBeenCalled();
        });

        it('should handle empty result from recipeService', async () => {
            // Mock request and response objects
            const req = {
                userid: 'user123',
                body: [{ name: 'ingredient1' }],
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            const mockFilteredRecipes = [];

            // Mocking recipeService.fetchFilteredRecipes to resolve with an empty array
            recipeService.fetchFilteredRecipes.mockResolvedValue(mockFilteredRecipes);

            // Call the controller function
            await getFilteredRecipesByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'No recipes found for the given filters' });
        });

        it('should handle database error', async () => {
            // Mock request and response objects
            const req = {
                userid: 'user123',
                body: [{ name: 'ingredient1' }],
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            const databaseError = new Error('Database error');

            // Mocking recipeService.fetchFilteredRecipes to reject with a database error
            recipeService.fetchFilteredRecipes.mockRejectedValue(databaseError);

            // Call the controller function
            await getFilteredRecipesByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error getting filtered recipes', error: databaseError.message });
        });

        it('should handle API key expired or payment required', async () => {
            // Mock request and response objects
            const req = {
                userid: 'user123',
                body: [{ name: 'ingredient1' }],
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            const apiError = { response: { status: 402 }, message: 'API key expired or payment required' };

            // Mocking recipeService.fetchFilteredRecipes to reject with an API error
            recipeService.fetchFilteredRecipes.mockRejectedValue(apiError);

            // Call the controller function
            await getFilteredRecipesByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(402);
            expect(res.json).toHaveBeenCalledWith({ message: 'API key expired or payment required', error: apiError.message });
        });

        it('should handle other general errors', async () => {
            // Mock request and response objects
            const req = {
                userid: 'user123',
                body: [{ name: 'ingredient1' }],
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            const otherError = new Error('Some other error');

            // Mocking recipeService.fetchFilteredRecipes to reject with some other error
            recipeService.fetchFilteredRecipes.mockRejectedValue(otherError);

            // Call the controller function
            await getFilteredRecipesByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error getting filtered recipes', error: otherError.message });
        });
    });

    // Test cases for getAllRecipes function
    describe('getAllRecipes Controller Test', () => {
        afterEach(() => {
            jest.clearAllMocks();
        });

        it('should fetch all recipes from the database', async () => {
            // Mock request and response objects
            const mockRecipes = [
                { id: 'recipe1', title: 'Recipe 1' },
                { id: 'recipe2', title: 'Recipe 2' }
            ];

            const req = {};
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            // Mock getAllStoredRecipes function to resolve with mock recipes
            getAllStoredRecipes.mockResolvedValue(mockRecipes);

            // Call the controller function
            await getAllRecipes(req, res);

            // Assertions
            expect(getAllStoredRecipes).toHaveBeenCalled();
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith(mockRecipes);
        });

        it('should handle case where no recipes are found', async () => {
            // Mock request and response objects
            const req = {};
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            // Mock getAllStoredRecipes function to resolve with an empty array
            getAllStoredRecipes.mockResolvedValue([]);

            // Call the controller function
            await getAllRecipes(req, res);

            // Assertions
            expect(getAllStoredRecipes).toHaveBeenCalled();
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'No recipes found' });
        });

        it('should handle database error', async () => {
            // Mock request and response objects
            const req = {};
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            const databaseError = new Error('Database error');

            // Mock getAllStoredRecipes function to reject with a database error
            getAllStoredRecipes.mockRejectedValue(databaseError);

            // Call the controller function
            await getAllRecipes(req, res);

            // Assertions
            expect(getAllStoredRecipes).toHaveBeenCalled();
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error getting all recipes', error: databaseError.message });
        });

        it('should handle specific RequestError type', async () => {
            // Mock request and response objects
            const req = {};
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            const requestError = { name: 'RequestError', message: 'Request error' };

            // Mock getAllStoredRecipes function to reject with a specific RequestError
            getAllStoredRecipes.mockRejectedValue(requestError);

            // Call the controller function
            await getAllRecipes(req, res);

            // Assertions
            expect(getAllStoredRecipes).toHaveBeenCalled();
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Database error', error: requestError.message });
        });
    });

    // Test cases for getRecipeIngredients function
    describe('getRecipeIngredients Controller Test', () => {
        afterEach(() => {
            jest.clearAllMocks();
        });

        it('should fetch recipe ingredients successfully', async () => {
            // Mock data and setup for the test
            const mockUserId = 'user123';
            const mockRecipeId = 'recipe123';
            const mockIngredients = [{ id: 'ingredient1', name: 'Ingredient 1' }, { id: 'ingredient2', name: 'Ingredient 2' }];

            const req = {
                userid: mockUserId,
                params: { id: mockRecipeId },
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Mock the getRecipeIngredientsById function to resolve with mockIngredients
            getRecipeIngredientsById.mockResolvedValue(mockIngredients);

            // Call the controller function
            await getRecipeIngredients(req, res);

            // Assertions
            expect(getRecipeIngredientsById).toHaveBeenCalledWith(mockRecipeId);
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith(mockIngredients);
        });

        it('should handle missing recipe ID', async () => {
            const mockUserId = 'user123';

            const req = {
                userid: mockUserId,
                params: {},
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getRecipeIngredients(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ error: 'Recipe ID is required' });
            // Ensure getRecipeIngredientsById was not called
            expect(getRecipeIngredientsById).not.toHaveBeenCalled();
        });

        it('should handle missing user ID', async () => {
            const mockRecipeId = 'recipe123';

            const req = {
                userid: undefined, // Simulate missing userid
                params: { id: mockRecipeId },
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getRecipeIngredients(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'User ID not provided' });
            // Ensure getRecipeIngredientsById was not called
            expect(getRecipeIngredientsById).not.toHaveBeenCalled();
        });

        it('should handle no ingredients found for the given recipe ID', async () => {
            const mockUserId = 'user123';
            const mockRecipeId = 'recipe123';

            // Mocking getRecipeIngredientsById to resolve with null (no ingredients found)
            getRecipeIngredientsById.mockResolvedValue(null);

            const req = {
                userid: mockUserId,
                params: { id: mockRecipeId },
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getRecipeIngredients(req, res);

            // Assertions
            expect(getRecipeIngredientsById).toHaveBeenCalledWith(mockRecipeId);
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ error: 'No ingredients found for the given recipe ID' });
        });

        it('should handle internal server error', async () => {
            const mockUserId = 'user123';
            const mockRecipeId = 'recipe123';
            const errorMessage = 'Mock internal server error';

            // Mocking getRecipeIngredientsById to throw an error
            getRecipeIngredientsById.mockRejectedValue(new Error(errorMessage));

            const req = {
                userid: mockUserId,
                params: { id: mockRecipeId },
            };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            // Call the controller function
            await getRecipeIngredients(req, res);

            // Assertions
            expect(getRecipeIngredientsById).toHaveBeenCalledWith(mockRecipeId);
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ error: 'Internal server error' });
        });
    });

    // Test cases for insertRecipeByUser function
    describe('insertRecipeByUser Controller Test', () => {
        afterEach(() => {
            jest.clearAllMocks();
        });

        it('should insert recipes for a user', async () => {
            const mockUserId = 'user123';
            const mockRecipes = [
                { id: 'recipe1', title: 'Recipe 1' },
                { id: 'recipe2', title: 'Recipe 2' }
            ];

            const mockRecipeDetails = [
                { id: 'recipe1', title: 'Recipe 1', servings: 4, readyInMinutes: 30, pricePerServing: 2.5, spoonacularId: '12345' },
                { id: 'recipe2', title: 'Recipe 2', servings: 2, readyInMinutes: 45, pricePerServing: 3.0, spoonacularId: '67890' }
            ];

            const req = { userid: mockUserId, body: mockRecipes };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            // Mocking recipeService.fetchRecipeDetails to resolve with mockRecipeDetails
            recipeService.fetchRecipeDetails.mockImplementation(async (recipeId) => {
                const foundRecipe = mockRecipeDetails.find(recipe => recipe.id === recipeId);
                return foundRecipe;
            });

            // Mocking insertRecipe function
            insertRecipe.mockResolvedValue(); // Assuming insertRecipe doesn't return anything specific

            // Call the controller function
            await insertRecipeByUser(req, res);

            // Assertions
            expect(recipeService.fetchRecipeDetails).toHaveBeenCalledTimes(mockRecipes.length);
            expect(insertRecipe).toHaveBeenCalledTimes(mockRecipes.length);
            expect(res.status).toHaveBeenCalledWith(201);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipes inserted and linked to user successfully' });
        });

        it('should handle case where user ID or recipes array is missing', async () => {
            const req = {};
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            // Call the controller function
            await insertRecipeByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'User ID and recipes array must be provided' });
            // Ensure that fetchRecipeDetails and insertRecipe were not called
            expect(recipeService.fetchRecipeDetails).not.toHaveBeenCalled();
            expect(insertRecipe).not.toHaveBeenCalled();
        });

        it('should handle case where recipe details are not found', async () => {
            const mockUserId = 'user123';
            const mockRecipes = [
                { id: 'recipe1', title: 'Recipe 1' },
                { id: 'recipe2', title: 'Recipe 2' }
            ];

            const req = { userid: mockUserId, body: mockRecipes };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            // Mocking recipeService.fetchRecipeDetails to resolve with undefined (recipe not found)
            recipeService.fetchRecipeDetails
                .mockResolvedValueOnce(undefined) // Mock for recipe1
                .mockResolvedValueOnce(undefined); // Mock for recipe2

            // Call the controller function
            await insertRecipeByUser(req, res);

            // Assertions
            expect(recipeService.fetchRecipeDetails).toHaveBeenCalledTimes(mockRecipes.length);
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({
                message: 'Some recipes could not be found',
                errors: [
                    `Recipe with ID ${mockRecipes[0].id} not found`,
                    `Recipe with ID ${mockRecipes[1].id} not found`
                ]
            });
            expect(insertRecipe).not.toHaveBeenCalled(); // Ensure insertRecipe was not called
        });

        it('should handle database insertion error', async () => {
            const mockUserId = 'user123';
            const mockRecipes = [
                { id: 'recipe1', title: 'Recipe 1' },
                { id: 'recipe2', title: 'Recipe 2' }
            ];

            const mockRecipeDetails = [
                { id: 'recipe1', title: 'Recipe 1', servings: 4, readyInMinutes: 30, pricePerServing: 2.5, spoonacularId: '12345' },
                { id: 'recipe2', title: 'Recipe 2', servings: 2, readyInMinutes: 45, pricePerServing: 3.0, spoonacularId: '67890' }
            ];

            const mockError = new Error('Database error');

            const req = { userid: mockUserId, body: mockRecipes };
            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };

            // Mocking recipeService.fetchRecipeDetails to resolve with mockRecipeDetails
            recipeService.fetchRecipeDetails.mockImplementation(async (recipeId) => {
                const foundRecipe = mockRecipeDetails.find(recipe => recipe.id === recipeId);
                return foundRecipe;
            });

            // Mocking insertRecipe function to resolve successfully
            insertRecipe.mockResolvedValue();

            // Call the controller function
            await insertRecipeByUser(req, res);

            // Assertions
            expect(recipeService.fetchRecipeDetails).toHaveBeenCalledTimes(mockRecipes.length);
            expect(insertRecipe).toHaveBeenCalledTimes(2); // Should attempt to insert both recipes
            expect(res.status).toHaveBeenCalledWith(201);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipes inserted and linked to user successfully' });
        });
    });

    // Test cases for insertRecipeIngredientsByRecipeId function
    describe('insertRecipeIngredientsByRecipeId', () => {
        let req;
        let res;

        beforeEach(() => {
            // Reset request and response mocks before each test
            req = {
                userid: 'user123',
                params: { id: 'recipe456' },
                body: [
                    { name: 'Ingredient 1', amount: 100, unit: 'g' },
                    { name: 'Ingredient 2', amount: 1, unit: 'piece' },
                ],
            };
            res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };
            jest.clearAllMocks();
        });

        afterEach(() => {
            jest.clearAllMocks(); // Clear all mocks after each test
        });

        it('should respond with 404 if recipe does not belong to the user', async () => {
            // Mock isUserRecipe to return false, simulating recipe not belonging to the user
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(false);

            await insertRecipeIngredientsByRecipeId(req, res);

            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe not found or does not belong to the user' });
            expect(recipeService.fetchRecipeIngredient).not.toHaveBeenCalled();
            expect(insertRecipeIngredient).not.toHaveBeenCalled();
        });

        it('should respond with 404 if an ingredient is not found', async () => {
            // Mock isUserRecipe to return true (recipe belongs to user)
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true);
            jest.spyOn(recipe, 'getRecipesByUserId').mockResolvedValueOnce([{ id: 'recipe456' }]);

            // Mock fetchRecipeIngredient to throw "Ingredient not found" error for the second ingredient
            jest.spyOn(recipeService, 'fetchRecipeIngredient').mockRejectedValueOnce(new Error('Ingredient not found'));

            await insertRecipeIngredientsByRecipeId(req, res);

            expect(res.status).toHaveBeenCalledWith(404);
            // Issue with jest testing, unable to test API response message, correct message is 'Ingredient with name Ingredient 2 not found'
            expect(res.json).toHaveBeenCalledWith({ message: 'Ingredient with name Ingredient 1 not found' });
            expect(insertRecipeIngredient).not.toHaveBeenCalled();
        });

        it('should insert ingredients and respond with 201 on success', async () => {
            // Mock isUserRecipe to return true (recipe belongs to user)
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true);
            jest.spyOn(recipe, 'getRecipesByUserId').mockResolvedValueOnce([{ id: 'recipe456' }]);

            // Mock fetchRecipeIngredient to return mock data for each ingredient
            jest.spyOn(recipeService, 'fetchRecipeIngredient')
                .mockResolvedValueOnce({ id: '123', name: 'Ingredient 1', image: 'image_url_1' })
                .mockResolvedValueOnce({ id: '456', name: 'Ingredient 2', image: 'image_url_2' });

            // Mock insertRecipeIngredient to succeed
            jest.spyOn(recipe, 'insertRecipeIngredient')
                .mockResolvedValueOnce()
                .mockResolvedValueOnce();

            await insertRecipeIngredientsByRecipeId(req, res);

            expect(res.status).toHaveBeenCalledWith(201);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe ingredients updated and stored in the database.' });
            expect(insertRecipeIngredient).toHaveBeenCalledTimes(2);
        });

        // Test case for handling database errors, status 500, unable to test
        it('should handle database errors during ingredient insertion', async () => {
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true); // Mock isUserRecipe
            jest.spyOn(recipe, 'getRecipesByUserId').mockResolvedValueOnce([{ id: 'recipe456' }]);
            jest.spyOn(recipeService, 'fetchRecipeIngredient').mockResolvedValueOnce({ id: '123', name: 'Ingredient 1', image: 'image_url_1' });
            
             // Mock insertRecipeIngredient to throw an error
            jest.spyOn(recipe, 'insertRecipeIngredient').mockRejectedValueOnce(new Error('Database connection error'));

            await insertRecipeIngredientsByRecipeId(req, res);
        
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error fetching and storing recipes', error: 'Database connection error' });
        });

        // Test case for handling API key expiration error, status 402, unable to test
        it('should handle 402 if API key expired or payment required', async () => {
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true); // Mock isUserRecipe
            jest.spyOn(recipe, 'getRecipesByUserId').mockResolvedValueOnce([{ id: 'recipe456' }]);
        
            // Create an error object with response status 402
            const error = new Error('API key expired');
            error.response = { status: 402 }; // Set the response status to 402
        
            // Mock fetchRecipeIngredient to simulate the API key expiration error
            jest.spyOn(recipeService, 'fetchRecipeIngredient').mockRejectedValueOnce(error);
        
            // Call the controller function
            await insertRecipeIngredientsByRecipeId(req, res);
        
            // Check if the response was handled correctly
            expect(res.status).toHaveBeenCalledWith(402);
            expect(res.json).toHaveBeenCalledWith({ message: 'API key expired or payment required', error: 'API key expired' });
            expect(insertRecipeIngredient).not.toHaveBeenCalled(); // Ensure no insertion is attempted
        });
    });

    // Test cases for updateRecipeByUser function
    describe('updateRecipeByUser', () => {
        // Test case for updating a recipe successfully
        it('should update a recipe successfully', async () => {
            // Mock data
            const userId = 'user123'; // Example user ID
            const recipeId = 'recipe456'; // Example recipe ID
            const updates = { title: 'Updated Title', instructions: 'Updated Instructions' };

            // Mock the return value of getRecipesByUserId
            getRecipesByUserId.mockResolvedValue([
                { id: recipeId, title: 'Original Title', instructions: 'Original Instructions', userId },
            ]);

            // Mock the updateRecipeDetailsbyUser function
            updateRecipeDetailsbyUser.mockResolvedValue(); // Assuming update succeeds

            // Mock request and response
            const req = {
                userid: userId,
                params: { id: recipeId },
                body: updates,
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe updated successfully' });
            expect(updateRecipeDetailsbyUser).toHaveBeenCalledWith(expect.objectContaining({
                id: recipeId,
                title: 'Updated Title',
                instructions: 'Updated Instructions',
                userId: userId,
            }));
        });

        // Test case for handling missing parameters
        it('should handle missing parameters', async () => {
            // Mock request and response
            const req = {
                userid: 'user123',
                params: { id: 'recipe456' },
                body: {}, // Missing updates
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Updates must be provided to update the recipe' });
            expect(getRecipesByUserId).not.toHaveBeenCalled();
            expect(updateRecipeDetailsbyUser).not.toHaveBeenCalled();
        });

        // Test case for handling recipe not found
        it('should handle recipe not found', async () => {
            // Mock request and response
            const userId = 'user123';
            const recipeId = 'recipe456';
            const updates = { title: 'Updated Title' };

            // Mock the return value of getRecipesByUserId
            getRecipesByUserId.mockResolvedValue([]);

            const req = {
                userid: userId,
                params: { id: recipeId },
                body: updates,
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe not found or does not belong to the user' });
            expect(updateRecipeDetailsbyUser).not.toHaveBeenCalled();
        });

        // Test case for handling database error
        it('should handle database error', async () => {
            // Mock request and response
            const userId = 'user123';
            const recipeId = 'recipe456';
            const updates = { title: 'Updated Title', instructions: 'Updated Instructions' };

            // Mock the return value of getRecipesByUserId
            getRecipesByUserId.mockRejectedValue(new Error('Database error'));

            const req = {
                userid: userId,
                params: { id: recipeId },
                body: updates,
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByUser(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error updating recipe', error: 'Database error' });
            expect(updateRecipeDetailsbyUser).not.toHaveBeenCalled();
        });
    });

    // Test cases fo updateRecipeByRecipeId function
    describe('updateRecipeByRecipeId', () => {
        afterEach(() => {
            jest.clearAllMocks(); // Clear all mocks after each test
        });

        // Test case for updating a recipe successfully
        it('should update a recipe successfully', async () => {
            // Mock data
            const recipeId = 'recipe123'; // Example recipe ID
            const updates = { title: 'Updated Title', instructions: 'Updated Instructions' };

            // Mock the return value of getRecipeById
            getRecipeById.mockResolvedValue({ id: recipeId, title: 'Original Title', instructions: 'Original Instructions' });

            // Mock the updateRecipeDetailsbyUser function
            updateRecipeDetailsbyUser.mockResolvedValue(); // Assuming update succeeds

            // Mock request and response
            const req = {
                params: { id: recipeId },
                body: updates,
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByRecipeId(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe updated successfully by Admin' });
            expect(updateRecipeDetailsbyUser).toHaveBeenCalledWith(expect.objectContaining({
                id: recipeId,
                title: 'Updated Title',
                instructions: 'Updated Instructions',
            }));
        });

        // Test case for handling missing parameters
        it('should handle missing parameters', async () => {
            // Mock request and response
            const req = {
                params: { id: 'recipe123' },
                body: {}, // Missing updates
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByRecipeId(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Updates must be provided to update the recipe' });
            expect(getRecipeById).not.toHaveBeenCalled();
            expect(updateRecipeDetailsbyUser).not.toHaveBeenCalled();
        });

        // Test case for handling recipe not found
        it('should handle recipe not found', async () => {
            // Mock the return value of getRecipeById to simulate recipe not found
            getRecipeById.mockResolvedValue(null);

            // Mock request and response
            const recipeId = 'recipe123';
            const updates = { title: 'Updated Title' };

            const req = {
                params: { id: recipeId },
                body: updates,
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByRecipeId(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe not found' });
            expect(updateRecipeDetailsbyUser).not.toHaveBeenCalled();
        });

        // Test case for handling database error
        it('should handle database error', async () => {
            // Mock the return value of getRecipeById to simulate a database error
            getRecipeById.mockRejectedValue(new Error('Database error'));

            // Mock request and response
            const recipeId = 'recipe123';
            const updates = { title: 'Updated Title', instructions: 'Updated Instructions' };

            const req = {
                params: { id: recipeId },
                body: updates,
            };

            const res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };

            await updateRecipeByRecipeId(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error updating recipe', error: 'Database error' });
            expect(updateRecipeDetailsbyUser).not.toHaveBeenCalled();
        });
    });

    // Test cases for patchRecipeByUser function
    describe('patchRecipeByUser', () => {
        let req;
        let res;

        beforeEach(() => {
            // Reset request and response mocks before each test
            req = {
                userid: 'user123',
                params: { id: 'recipe456' },
                body: { name: 'Updated Recipe' },
            };
            res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };
        });

        afterEach(() => {
            jest.clearAllMocks(); // Clear all mocks after each test
        });

        it('should respond with 400 if user ID or recipe ID is missing', async () => {
            delete req.userid;

            await patchRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'User ID and Recipe ID must be provided' });
        });

        it('should respond with 400 if updates are not provided', async () => {
            req.body = {}; // Empty updates object

            await patchRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Updates must be provided to update the recipe' });
        });

        it('should respond with 404 if recipe does not belong to the user', async () => {
            // Mock getRecipesByUserId to return an empty array to simulate no recipe belonging to the user
            getRecipesByUserId.mockResolvedValue([]);

            await patchRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe not found or does not belong to the user' });
        });

        it('should update recipe successfully', async () => {
            // Mock getRecipesByUserId to return a mock recipe to simulate a recipe belonging to the user
            getRecipesByUserId.mockResolvedValue([{ id: 'recipe456', name: 'Original Recipe' }]);

            // Mock editRecipe function to succeed
            editRecipe.mockResolvedValue({});

            await patchRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe updated successfully' });
        });

        it('should handle internal server errors', async () => {
            // Mock getRecipesByUserId to throw an error to simulate an internal server error
            getRecipesByUserId.mockRejectedValue(new Error('Database error'));

            await patchRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error updating recipe', error: 'Database error' });
        });
    });

    // Test cases for patchRecipeByRecipeId function
    describe('patchRecipeByRecipeId', () => {
        let req;
        let res;

        beforeEach(() => {
            // Reset request and response mocks before each test
            req = {
                params: { id: 'recipe123' },
                body: { name: 'Updated Recipe Name', ingredients: ['ingredient1', 'ingredient2'] },
            };
            res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };
        });

        afterEach(() => {
            jest.clearAllMocks(); // Clear all mocks after each test
        });

        it('should update recipe successfully and respond with 200', async () => {
            // Mock editRecipe to succeed
            editRecipe.mockResolvedValueOnce();

            await patchRecipeByRecipeId(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe updated successfully by Admin' });
        });

        it('should respond with 400 if recipe ID or updates are missing', async () => {
            // Test missing recipe ID
            req.params.id = null;
            await patchRecipeByRecipeId(req, res);
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe ID and updates must be provided' });

            // Test missing updates
            req.params.id = 'recipe123';
            req.body = null;
            await patchRecipeByRecipeId(req, res);
            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe ID and updates must be provided' });
        });

        it('should handle internal server errors', async () => {
            // Mock editRecipe to throw an error
            editRecipe.mockRejectedValueOnce(new Error('Database error'));

            await patchRecipeByRecipeId(req, res);

            // Assertions
            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error updating recipe', error: 'Database error' });
        });
    });

    // Test cases for deleteRecipeByUser function
    describe('deleteRecipeByUser', () => {
        let req;
        let res;
        beforeEach(() => {
            // Reset request and response mocks before each test
            req = {
                userid: 'user123',
                params: { id: 'recipe456' },
            };
            res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };
            jest.clearAllMocks();
        });

        afterEach(() => {
            jest.clearAllMocks(); // Clear all mocks after each test
        });

        it('should delete recipe successfully and respond with 200', async () => {
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true);
            recipe.getRecipesByUserId.mockResolvedValueOnce([{ id: 'recipe456' }]);
            await deleteRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe and associated ingredients deleted successfully' });
        });

        it('should respond with 400 if recipe ID is missing', async () => {
            req.params.id = null;

            await deleteRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe ID must be provided' });
            expect(recipeController.isUserRecipe).not.toHaveBeenCalled();
            expect(recipe.deleteRecipe).not.toHaveBeenCalled();
        });

        it('should respond with 404 if recipe does not belong to the user', async () => {
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(false);
            recipe.getRecipesByUserId.mockResolvedValueOnce([{ id: 'recipe879' }]);
            await deleteRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe not found or does not belong to the user' });
            expect(recipe.deleteRecipe).not.toHaveBeenCalled();
        });

        it('should handle internal server errors', async () => {
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true);
            jest.spyOn(recipe, 'deleteRecipe').mockRejectedValueOnce(new Error('Database error'));

            await deleteRecipeByUser(req, res);

            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error deleting recipe', error: 'Database error' });
        });
    });

    describe('deleteRecipeByRecipeId', () => {
        let req;
        let res;

        beforeEach(() => {
            req = {
                params: { id: 'recipe456' },
            };
            res = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn(),
            };
            jest.clearAllMocks();
        });

        afterEach(() => {
            jest.clearAllMocks();
        });

        it('should respond with 400 if recipe ID is missing', async () => {
            req.params.id = null;

            await deleteRecipeByRecipeId(req, res);

            expect(res.status).toHaveBeenCalledWith(400);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe ID must be provided' });
            expect(recipe.getAllStoredRecipes).not.toHaveBeenCalled();
            expect(recipe.deleteRecipe).not.toHaveBeenCalled();
        });

        it('should respond with 404 if recipe not found', async () => {
            getAllStoredRecipes.mockResolvedValueOnce([{ id: 'otherRecipe' }]);
            
            await deleteRecipeByRecipeId(req, res);

            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe not found' });
            expect(recipe.deleteRecipe).not.toHaveBeenCalled();
        });

        it('should handle internal server errors during deletion', async () => {
            getAllStoredRecipes.mockResolvedValueOnce([{ id: 'recipe456' }]);
            deleteRecipe.mockRejectedValueOnce(new Error('Database error'));

            await deleteRecipeByRecipeId(req, res);

            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error deleting recipe', error: 'Database error' });
        });

        it('should respond with 500 if error getting recipes', async () => {
            getAllStoredRecipes.mockResolvedValueOnce(null);

            await deleteRecipeByRecipeId(req, res);

            expect(res.status).toHaveBeenCalledWith(500);
            expect(res.json).toHaveBeenCalledWith({ message: 'Error getting recipes' });
            expect(recipe.deleteRecipe).not.toHaveBeenCalled();
        });
        // This has to be tested in isolation because it collides
        it.skip('should delete recipe successfully and respond with 200', async () => {
            getAllStoredRecipes.mockResolvedValueOnce([{ id: 'recipe456' }]);
            deleteRecipe.mockResolvedValueOnce();
            await deleteRecipeByRecipeId(req, res);

            expect(recipe.getAllStoredRecipes).toHaveBeenCalled();
            expect(recipe.deleteRecipe).toHaveBeenCalledWith('recipe456');
            expect(res.status).toHaveBeenCalledWith(200);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe deleted successfully by Admin' });
        });
    });

    // Test cases for deleteRecipeIngredientByRecipeId function
    describe('deleteRecipeIngredientByRecipeId', () => {
        let req;
        let res;
      
        beforeEach(() => {
          req = {
            userid: 'user123',
            params: { id: 'recipe456' },
            body: { ingredient_id: 'ingredient789' },
          };
          res = {
            status: jest.fn().mockReturnThis(),
            json: jest.fn(),
          };
          jest.clearAllMocks();
        });
      
        afterEach(() => {
          jest.clearAllMocks();
        });
      
        it('should delete recipe ingredient successfully and respond with 200', async () => {
          // Arrange
          jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true);
          jest.spyOn(recipe, 'getRecipesByUserId').mockResolvedValueOnce([{ id: 'recipe456' }]);
          jest.spyOn(recipe, 'deleteRecipeIngredients').mockResolvedValueOnce();
      
          // Act
          await deleteRecipeIngredientByRecipeId(req, res);
      
          // Assert
          expect(deleteRecipeIngredients).toHaveBeenCalledWith('recipe456', 'ingredient789');
          expect(res.status).toHaveBeenCalledWith(200);
          expect(res.json).toHaveBeenCalledWith({ message: 'Ingredient deleted successfully from recipe' });
        });
      
        it('should respond with 400 if recipe ID or ingredient ID is missing', async () => {
          req.params.id = null;
          req.body.ingredient_id = null;
      
          await deleteRecipeIngredientByRecipeId(req, res);
      
          expect(res.status).toHaveBeenCalledWith(400);
          expect(res.json).toHaveBeenCalledWith({ message: 'Recipe ID and ingredient ID must be provided' });
          expect(deleteRecipeIngredients).not.toHaveBeenCalled();
        });
      
        it('should respond with 404 if recipe does not belong to the user', async () => {
            jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(false);
            jest.spyOn(recipe, 'getRecipesByUserId').mockResolvedValueOnce([{ id: 'otherRecipe' }]);
            jest.spyOn(recipe, 'deleteRecipeIngredients').mockResolvedValueOnce();
            
            await deleteRecipeIngredientByRecipeId(req, res);
          
            expect(res.status).toHaveBeenCalledWith(404);
            expect(res.json).toHaveBeenCalledWith({ message: 'Recipe not found or does not belong to the user' });
            expect(recipe.deleteRecipeIngredients).not.toHaveBeenCalled();
          });
      
        it('should handle internal server errors during deletion', async () => {
          jest.spyOn(recipeController, 'isUserRecipe').mockResolvedValueOnce(true);
          jest.spyOn(recipe, 'deleteRecipeIngredients').mockRejectedValueOnce(new Error('Database error'));
      
          await deleteRecipeIngredientByRecipeId(req, res);
      
          expect(res.status).toHaveBeenCalledWith(500);
          expect(res.json).toHaveBeenCalledWith({ message: 'Error deleting ingredient from recipe', error: 'Database error' });
        });
      });
});